# C++14

## *变量模板*
* 语法:
  ```cpp 
  template <形参列表> 变量声明;
  ```
* 解释：从变量模板实例化的变量被称为被实例化变量，从静态数据成员模板实例化的变量被称为被实例化静态数据成员。

## *泛型`lambda`表达式* 
* 新增了`auto`关键字，可以在`lambda`表达式中的形参使用泛型参数，以他们的顺序设置一个隐藏的模板形参，当对应的是函数形参包时，它可以是形参包。
  > C++14起
  > ```cpp
  >  // 泛型 lambda，operator() 是有两个形参的模板
  >  auto glambda = [](auto a, auto&& b) { return a < b; };
  >  bool b = glambda(3, 3.14); // ok
  >
  > // 泛型 lambda，operator() 是有一个形参的模板
  >  auto vglambda = [](auto printer)
  >  {
  >      return [=](auto&&... ts) // 泛型 lambda，ts 是形参包
  >      {
  >          printer(std::forward<decltype(ts)>(ts)...);
  >          // 零元 lambda （不接受形参）
  >          return [=] { printer(ts...); };
  >      };
  >  };
  >
  >  auto p = vglambda([](auto v1, auto v2, auto v3)
  >  {
  >      std::cout << v1 << v2 << v3;
  >  });
  >
  >  auto q = p(1, 'a', 3.14); // 输出 1a3.14
  >  q();                      // 输出 1a3.14
  >  ```

## *二进制字面量*
* 二进制字面量的前缀是`0b`或`0B`，后面跟一串0和1的数字序列。
  > C++14起
  > ```cpp
  >  int a = 0b1010; // 10
  >  int b = 0B1010; // 10
  >  ```

## *返回类型推导*
* C++14起，如果函数的返回类型是`auto`，那么可以省略返回类型。
  > C++14起
  > ```cpp
  >  auto add(int a, int b)
  >  {
  >      return a + b;
  >  }
  >  ```
* 注意：仍有一些情况下不能省略返回类型
  1. 递归函数
  2. 有多个`return`语句的函数，且返回类型不同
  3. 没有`return`语句，或者返回值类型为`void`的函数
  4. 无法返回使用`{}`包围的初始化器列表的函数
  5. 虚函数不能使用返回类型推导

## *`std::make_unique`*
* `std::make_unique`是`std::unique_ptr`的工厂函数，用于创建`std::unique_ptr`对象。
  > C++14起
  > ```cpp
  >  std::unique_ptr<int> p = std::make_unique<int>(42);
  >  ```
* 意义：
  1. 简化代码，避免手动使用new和delete，以及确保资源的正确释放而设计的。
  2. 统一代码风格，即为`std::make_shared`的`std::unique_ptr`版本。

## *`std::shared_timed_mutex`*
* `std::shared_timed_mutex`在头文件`<shared_mutex>`中定义，是一种同步原语的类。<br>
  与其他独占访问的互斥锁类型不同的是，它提供了两个访问层级：
  * *共享 -* 多个线程能共享同一互斥锁的所有权。
  * *独占 -* 仅一个线程能占有互斥锁的所有权。
  > C++14起
  > ```cpp
  >  std::shared_timed_mutex m;
  >  std::unique_lock<std::shared_timed_mutex> lock(m);
  >  ```
* 意义：用于实现读写锁，提供了更细粒度的控制，允许多个线程同时读取共享数据，但只允许一个线程写入数据，当有线程写入数据时，其他线程不能读取数据。
* 注意：`std::shared_timed_mutex`是C++14新增的，C++17中增加了`std::shared_mutex`，与`std::shared_timed_mutex`相比，`std::shared_mutex`不支持超时。
* 使用场景：
  1. 读多写少，提高并发性能。
  2. 需要超时机制，避免死锁（与`std::shared_mutex`最大的区别）。
* 成员函数：
  * 排他性操作：
     >（常见于写操作，这些操作会禁止所有其他的线程访问）<br>

    `lock` - 获取互斥锁的所有权，如果互斥锁已经被其他线程占有，则阻塞当前线程。<br>
    `try_lock` - 尝试获取互斥锁的所有权，如果互斥锁已经被其他线程占有，则立即返回`false`。<br>
    `try_lock_for` - 尝试获取互斥锁的所有权，如果互斥锁已经被其他线程占有，则等待一段时间，如果超时则返回`false`。<br>
    `try_lock_until` - 尝试获取互斥锁的所有权，如果互斥锁已经被其他线程占有，则等待到指定时间点，如果超时则返回`false`。<br>
    `unlock` - 释放互斥锁的所有权。<br>
  * 共享性操作 ：
    > （常见于读操作，这些操作允许多个线程同时访问,但会阻止写操作）<br>

    `lock_shared` - 获取共享互斥锁的所有权，如果互斥锁已经被其他线程占有，则阻塞当前线程。<br>
    `try_lock_shared` - 尝试获取共享互斥锁的所有权，如果互斥锁已经被其他线程占有，则立即返回`false`。
    `try_lock_shared_for` - 尝试获取共享互斥锁的所有权，如果互斥锁已经被其他线程占有，则等待一段时间，如果超时则返回`false`。<br>
    `try_lock_shared_until` - 尝试获取共享互斥锁的所有权，如果互斥锁已经被其他线程占有，则等待到指定时间点，如果超时则返回`false`。<br>
    * `unlock_shared` - 释放共享互斥锁的所有权。<br>
* 建议使用`std::unique_lock`和`std::shared_lock`来管理`std::shared_timed_mutex`的所有权，而不是直接调用`lock`和`unlock`，因为`std::unique_lock`和`std::shared_lock`会自动释放互斥锁的所有权。

## *`std::shared_lock`*
* `std::shared_lock`是类似于`std::unique_lock`的RAII风格的类，用于管理线程，常与`std::unique_lock`一起管理`std::shared_timed_mutex`的所有权。
  > C++14起
  > ```cpp
  >  std::shared_timed_mutex m;
  >  std::shared_lock<std::shared_timed_mutex> lock(m);
  >  ```
* 注意：`std::shared_lock`与`std::unique_lock`的区别在于，`std::shared_lock`允许多个线程同时访问共享数据，而`std::unique_lock`只允许一个线程访问共享数据，相同的是，它们都是RAII风格的类，用于管理线程，且都不支持拷贝构造和拷贝赋值。

## *`std::exchange`*
* `std::exchange`用于替换一个对象的值，并返回旧值。
  > C++14起
  > ```cpp
  >  int a = 1;
  >  int b = std::exchange(a, 2); // a = 2, b = 1
  >  ```
* 意义：
  1. `std::exchange`是C++14新增的，用于替换一个对象的值，并返回旧值，与`std::swap`不同的是，`std::exchange`只替换一个对象的值，而`std::swap`交换两个对象的值。
  2. `std::exchange`是一个移动操作，不会复制对象的值，因此效率更高。


## *`std::interger_sequence`*
* `std::interger_sequence`是一个模板类，常用于模板元编程中，用于生成一个整数序列，需要包含头文件`<utility>`。
* 语法：
  ```cpp
  template <typename T, T... Ints>
  struct integer_sequence
  {
      using value_type = T;
      static constexpr std::size_t size() noexcept { return sizeof...(Ints); }
  };
  ```
* 意义：简化模板元编程中的代码，用于生成一个整数序列，常用于模板元编程中，如`std::index_sequence`和`std::make_index_sequence`。


# C++17
---
## 新语法特性
### 变量
#### *`结构化绑定`*
* `结构化绑定`是`C++17`新增的特性，允许将一个储存多个值的对象（如`std::pair`、`std::tuple`等）的成员绑定到多个变量上。
  >  ```cpp
  >  // C++11/C++14
  >  std::pair<int, double> p = {1, 3.14};
  >  int i = p.first;
  >  double d = p.second;
  >  // C++17及以后
  >  std::pair<int, double> p = {1, 3.14};
  >  auto [i, d] = p;
  >  ```
  详见：[structured_binding](../src/C++17/structured_binding.cpp)
* 意义：`结构化绑定`是`C++17`新增的特性，用于将`std::pair`、`std::tuple`等类型的对象的成员绑定到变量上，提高了代码的可读性和可维护性，避免了手动解包的麻烦。

#### *`聚合体`*
* `聚合体`是`C++17`为了描述一个复合型数据类型的对象。
* 满足条件：
  1. 是一个数组。
  2. 或者是满足以下条件的类类型（`class`、`struct`、`union`)：
      - 没有用户提供的和`explicit`的构造函数
      - 没有使用`using`声明继承的构造函数
      - 没有`virtual`（虚函数）
      - 没有`private`、`protected`的非静态数据成员
      - 没有`virtual`（虚函数），`private`、`protected`的基类
##### *`聚合体初始化`*
* `C++17`中，`聚合体`可以使用`花括号`进行初始化。
  >  ```cpp
  >  // C++17及以后
  >  struct A {int i; double d;};
  >  A a = {42, 3.14};
  >  ```
  详见：[aggregate](../src/C++17/aggregate.cpp)
* 但`聚合体`需要额外满足以下条件：
  : 基类没有`private`、`protected`的成员
  : 没有`private`、`protected`的构造函数
* 注意：`聚合体初始化`是`C++`少数向后不兼容的特性之一，这意味着，如果你的代码在`C++11`或`C++14`中编译通过，但在`C++17`中编译不通过，那么很有可能是因为`聚合体初始化`的问题。

#### *`if`和`switch`中的初始化*
* `C++17`中，`if`和`switch`语句允许在条件表达式里添加一条初始化语句。
  >  ```cpp
  >  // C++17及以后
  >  if (int i = 42; i > 0) {statement;}
  >  switch (int i = 42; i) {case 42: statement;}
  >  ```
  详见：[if_switch](../src/C++17/if_switch.cpp)
* 意义：通过在`if`和`switch`语句中添加初始化语句，方便管理条件判断的变量的作用域，特别是在多线程环境下，避免了变量的污染，这样保证了变量仅在`if`和`switch`语句中有效，而在外部下未被初始化。

#### *`复制消除`*
* `C++17`中，`复制消除`是一个新的优化，用于消除不必要的复制操作，程序员无需自己关系优化的细节。
* 影响：
  : 从技术上讲，`C++17`强制要求编译器满足以下规则：当以值传递参数时，编译器必须在函数调用时进行`复制消除`（即必须省略对该临时变量的拷贝。
  : 从效果上讲，`C++17`中，程序员无需关心优化的细节，只需按照最佳实践编写代码，编译器会自动进行优化，实际上只是将`RVO (Return Value Optimization)`和`NRVO (Named Return Value Optimization)`的`C++编译器`优化行为强制转为默认行为。[^1:RVO和NRVO]

### 模板
#### *`类模板参数推到`*
* `C++17`起，类模板参数推导允许在模板类的构造函数中推导模板参数。
  > ```cpp
  >  // C++17起
  >  template <typename T>
  >  struct A
  >  {
  >      A(T t) {}
  >  };
  >  A a(42); // T被推导为int
  >  ```
  详见：[class_template](../src/C++17/class_template.cpp)
* 注意：必须是编译器可以推导的情况下，才能使用类模板参数推导，且默认以拷贝方式推导，但在推导可变参数模板时，会有糟糕的实现，因为每种编译有不同的实现，而且不允许部分推导。

#### *`auto推断非类型模板参数`*
* `C++17`之前，如果我们需要传递部分实参（如`std::array<int,3>`其中的`3`），必须要显示指定类型，或者采用以下形式：
    >```cpp
    >  //C++17前
    >  //必须声明两个模板变量
    >  template<typename T, T N> void add(int &a){a+=N;}
    >  //C++17后
    >  //仅需要声明一个auto变量即可
    >  template<auto N> void add(int &a){a+=N;}
    >  //如果使用decltype(auto)则会推断为引用
    >  template<decltype(auto) N) void add(int &a){a+=N;}
    >  //还可以通过decltype(N)来设置模板变量
    >  template<auto N, typename T = decltype(N)> void add(T&a)(a+=N);
    >```
    详见：[auto_template](../src/C++17auto_template.cpp)

#### *`推导指引`*
* `C++17`起，程序员可以为类模板设置一个`推导指引`，用于指导编译器如何推导模板参数。
  > ```cpp
  >  // C++17起
  >  template <typename T>
  >  struct A
  >  {
  >      A(T t) {}
  >      template <typename U>
  >      A(U u) -> A<std::vector<U>>;
  >  };
  >  A a(std::vector<int>{1, 2, 3}); // T被推导为int
  >  ```
  详见：[class_template](../src/C++17/class_template.cpp)
* 与`构造函数`不同，`推导指引`可以避免在数组类型中仍被推导为数组类型，而是退化为指针类型，并且优先级高于构造函数。

##### *` 非模板推导`*
* `推导指引`可以设计为一个合理的类型映射，而不仅仅是模板参数的推导。
  > ```cpp
  >  // C++17起
  >  template <typename T>
  >  struct A
  >  {
  >      T val;
  >  };
  >  A(const char*) -> A<std::string>; // 把const char*映射为std::string
  >  ```
  详见：[class_template](../src/C++17/class_template.cpp)
##### *`显示推导指引`*
* `推导指引`可以用`explicit`声明。当出现`explicit`不允许的初始化或转换时，该`引导指引`将会被忽略。
  > ```cpp
  >  // C++17起
  >  template <typename T>
  >  struct A
  >  {
  >      T val;
  >  };
  >  explicit A(const char*) -> A<std::string>; // 把const char*映射为std::string
  >  A a = {"hello"}; // 错误，因为推导指引是explicit的
  >  A a1{"hello"}; // 正确，等同于A<std::string> a1{"hello"};
  >  A a2 = A{"hello"}; // 正确
  >  A a3 = {A{"hello"}}; // 正确
  >  ```
  详见：[class_template](../src/C++17/class_template.cpp)
##### *`标准推导指引`*
* `C++17`起，标准库中的`std::pair`和`std::tuple`等类模板都提供了`推导指引`。
  > ```cpp
  >  // C++17起
  >  std::pair p(1, 3.14); // 推导为std::pair<int, double>
  >  std::tuple t(1, 3.14, "hello"); // 推导为std::tuple<int, double, const char*>
  >  ```
  详见：[class_template](../src/C++17/class_template.cpp)
* 支持：所有`STL`容器和对应的迭代器。
* 注意：`智能指针`无法使用`推导指引`，因为会导致歧义：一个对象的指针和一个对象的数组，拥有或者退化以后拥有相同的类型

#### *`折叠表达式`*
* `C++17`起，`折叠表达式`是一种新的表达式，用于对模板参数包进行展开。
  > ```cpp
  >  // C++17起
  >  template <typename... Args>
  >  auto sum(Args... args)
  >  {
  >      return (args + ...);
  >  }
  >  int s = sum(1, 2, 3, 4, 5); // s = 15
  >  ```
  详见：[fold_expression](../src/C++17/fold_expression.cpp)
* 意义：`折叠表达式`是`C++17`新增的特性，用于对模板参数包进行展开，避免了手动展开的麻烦，在`C++17`前，需要重载一个递归实例化模板，用于处理参数包的展开，而`折叠表达式`则可以直接展开参数包，不仅减少了程序员的工作量，也减少了编译器的工作量。
##### *`折叠方式`*
* `折叠表达式`有两种折叠方式：
  : `左折叠` - `(... op pack)`，从左到右展开参数包。
  : `右折叠` - `(pack op ...)`，从右到左展开参数包。
  > ```cpp
  > // C++17起
  > // 左折叠
  > template <typename... Args>
  > auto lsum(Args... args)
  > {
  >     return (args + ...); // 等价于 return (((1 + 2) + 3) + 4);
  > }
  > // 右折叠
  > template <typename... Args>
  > auto rsum(Args... args)
  > {
  >    return (... + args); // 等价于 return (1 + (2 + (3 + 4)));
  > }
  > ```
  详见：[fold_expression](../src/C++17/fold_expression.cpp)
* 这意味着，在部分情况下，`左折叠`和`右折叠`的结果是不同的，特别时在字符串操作：
  > ```cpp
  > lsum(std::string("hello "),"world","!"); // True,"hello world!"
  > rsum(std::string("hello "),"world","!"); // Error,因为右折叠是从右到左展开，而字符串之间无法直接相加，必须其中有一个是`std::string`类型，因为`std::string`重载了`+`运算符,反正亦然。
  > ```
  详见：[fold_expression](../src/C++17/fold_expression.cpp)
##### *`折叠操作符`*
* `折叠表达式`不仅支持简单的`一元操作符`（`+`、`-`、`*`、`/`等），还支持`二元操作符`（`&&`、`||`、`&`、`|`等）。
  > ```cpp
  > // C++17起
  > template <typename... Args>
  > auto band(Args... args)
  > {
  >     return (args && ...); // 等价于 return (((1 && 2) && 3) && 4);
  > }
  > template <typename... Args>
  > auto bor(Args... args)
  > {
  >     return (args || ...); // 等价于 return (((1 || 2) || 3) || 4);
  > }
  > ```
  详见：[fold_expression](../src/C++17/fold_expression.cpp)
* 形式如：`(... op pack)`和`(pack op...)`，其中`op`是`二元操作符`，`pack`是参数包，`...`是折叠操作符，用于展开参数包。

### *`新增属性`* 
* `[[nodiscard]]`用于告知编译器，返回值不应该被忽略，如果被忽略，编译器会发出警告。
* `[[maybe_unused]]`用于告知编译器，变量可能未被使用，如果被使用，编译器不会发出警告。
* `[[fallthrough]]`用于告知编译器，`switch`语句中的`case`标签没有`break`，并且是有意为之的，如果没有`[[fallthrough]]`，编译器会发出警告。
  >  ```cpp
  >  // C++17起
  >  [[nodiscard]] int func();
  >  ```
  详见：[attribute](../src/C++17/attribute.cpp)
* wei
#### *`属性适用范围扩展`*
* 自`C++17`起，属性可以应用于函数、类、枚举、变量、模板参数等。
  >  ```cpp
  >  // C++17起
  >  [[nodiscard]] int func();
  >  [[nodiscard]] class A {};
  >  [[nodiscard]] enum class Color {red, green, blue};
  >  [[nodiscard]] int x;
  >  template <typename T> [[nodiscard]] void func(T t) {}
  >  ```
  详见：[attribute](../src/C++17/attribute.cpp)

### 其他
#### *`noexcept`变为类型*
* `C++17`中，`noexcept`被视为类型的一部分，这样跟方便于模板的编写，以及自定义的类型(using 语句)。
* 语法：
  >  ```cpp
  >  // C++11/C++14
  >  void func() noexcept;
  >  void (*funcptr)() noexcept = &func;
  >  // C++17及以后
  >  void func() noexcept;
  >  using FuncType = void() noexcept;
  >  FuncType* func = &func;
  >  ```
  详见：[noexcept](../src/C++17/noexcept.cpp)

#### *`constexpr`*
##### *`if constexpr`*
* 提供了在编译期处理条件分歧的功能，通过这个`C++`就拥有了一个更加强大的条件分支系统。
  >  ```cpp
  >  // 运行时条件分支，运行时处理
  >  if (condition) {statement_1;}
  >  else if (condition){statement_2;}
  >  else{statement_3;}
  >  // 编译时条件分支，C++17起，编译时期处理（跟模板同一时间处理）
  >  if constexpr (condition) {statement_1;}
  >  else if constexpr (condition){statement_2;}
  >  else{statement_3;}
  >  // 预处理条件分支，最先处理
  >  #if condition
  >    statement_1;
  >  #elif condition
  >    statement_2;
  >  #else
  >    statement_3;
  >  #endif
  >  ```
  详见：[if constexpr](../src/C++17/if_constexpr.cpp)
* 意义：`if constexpr`是`C++17`新增的特性，用于在编译期处理条件分歧，减少运行时的开销，即在编译时期处理，而不是在运行时期处理，生成的汇编代码只会包含符合条件的代码，不会包含不符合条件的代码。

#### *`lambda`表达式的扩展*
* `C++17`起，`lambda`表达式的功能得到了扩展，包括：
    : `lambda`表达式默认为`constexpr`，可以在编译期进行计算。（常见于模板元编程，提升性能）
    : `lambda`表达式可以捕获`*this`指针,复制一份对象到`lambda`表达式中。（解决多线程编程的类对象与lambda生命周期问题)
  >  ```cpp
  >  // C++17起
  >  int x = 42;
  >  auto f = [x](int y) {return x + y;};
  >  ```
  详见：[lambda](../src/C++17/lambda.cpp)
* 在这之前，如果捕获`*this`指针，如果编译器支持`C++17`则会发出警告：`‘*this’ capture only available with ‘-std=c++17’ or ‘-std=gnu++17’`，或者直接报错。

##### *`lambda类型推导`*
* `C++17`起，`lambda`表达式的参数可以使用`auto`进行类型推导。
  > ```cpp
  >  // C++17起
  >  //CountCalls需要接收一个函数对象，用于比较两个值的大小
  >  CountCalls sc{[](auto x,auto y){return x>y;}};
  >  ```
  详见：[lambda_template](../src/C++17/lambda.cpp)

#### *`__has_include`*
* `__has_include`是一个预处理宏，用于检查指定的头文件是否存在。
  > ```cpp
  >  // C++17起
  >  #if __has_include(<iostream>)
  >  #include <iostream>
  >  #endif
  >  ```
  详见：[has_include](../src/C++17/has_include.cpp)
> [!NOTE]
> `__has_include`是一个纯粹的预处理指令。 所以不能将它用作源码里的条件表达式。

---
## 头文件和工具
### *`<any>`头文件*
#### *`std::any`*
* `std::any`是一个类型安全的容器，可以存储任意类型的对象，包括基本类型、自定义类型、指针等。
  > ```cpp
  >  // C++17起
  >  std::any a = 1;
  >  std::any b = 3.14;
  >  std::any c = std::string("hello");
  >  std::any d = new int(42);
  >  ```
  详见：[any](../src/C++17/any_test.cpp)
* 意义：`std::any`是`C++17`新增的特性，用于存储任意类型的对象，可以替代`void*`指针，避免了类型不安全的问题，提高了代码的可读性和可维护性。
* 成员函数：
  : `std::any::type` - 返回`std::type_info`类型的对象，表示存储的对象的类型。
  : `std::any::has_value` - 返回一个`bool`值，表示`std::any`是否包含值。
  : `std::any::reset` - 重置`std::any`，将其置为空。
  : `std::any::swap` - 交换两个`std::any`对象的值。
  : `std::any::emplace` - 用于在`std::any`中构造对象。
#### *`std::any_cast`*
* `std::any_cast`是一个模板函数，用于从`std::any`中获取对象。
  > ```cpp
  >  // C++17起
  >  std::any a = 1;
  >  int i = std::any_cast<int>(a);
  >  ```
  详见：[any](../src/C++17/any_test.cpp)
* 意义：`std::any_cast`是`C++17`新增的特性，用于从`std::any`中获取对象，并进行类型转换，为安全的类型访问操作（类型匹配失败会抛出`std::bad_any_cast`异常）。
#### *`std::make_any`*
* `std::make_any`是一个工厂函数，用于创建`std::any`对象。
  > ```cpp
  > // C++17起
  >  auto a = std::make_any<int>(42);
  >  ```
  详见：[any](../src/C++17/any_test.cpp)
* 意义：`std::make_any`是`C++17`新增的特性，用于创建`std::any`对象，避免了手动构造`std::any`对象，提高了代码的可读性和可维护性（特别是在模板，如包装器类中，类型不匹配出现的错误）。
* 注意：`std::any_cast`是一个模板函数，需要指定模板参数，用于指定要获取的对象的类型。
#### *`std::bad_any_cast`*
* `std::bad_any_cast`是一个异常类，用于辅助`std::any_cast`进行异常处理。
  > ```cpp
  >  // C++17起
  >  try
  >  {
  >      int i = std::any_cast<int>(a);
  >  }
  >  catch (const std::bad_any_cast& e)
  >  {
  >      std::cout << e.what() << std::endl;
  >  }
  >  ```
  详见：[any](../src/C++17/any_test.cpp)
* 意义：`std::bad_any_cast`是`C++17`新增的特性，用于辅助`std::any_cast`进行异常处理，当类型转换失败时，抛出`std::bad_any_cast`异常。
* 成员函数：
  : `std::bad_any_cast::what` - 返回一个`const char*`类型的字符串，表示异常的原因。
  : `std::bad_any_cast::operator=` - 赋值运算符，用于复制异常对象。

### *`<optional>`头文件*
#### *`std::optional`*
* `std::optional`是管理一个*可选*的所含值，即可能有值，也可能没有值。
  > ```cpp
  >  // C++17起
  >  std::optional<int> opt;
  >  opt = 42;
  >  ```
  详见：[optional](../src/C++17/optional_test.cpp)
* 意义：一种常见的`std::optional`使用情况是作为可能识别的函数返回值，并且不会产生动态分配的内存，相较于其他的返回值处理方式，`std::optional`允许延迟构造，这对处理构造开销高昂的对象是非常有用的，并且使用它已经明确表明了函数可能没有返回值的情况。
* 成员函数：
  : `std::optional::value` - 返回`std::optional`中的值，如果`std::optional`为空，则抛出`std::bad_optional_access`异常。
  : `std::optional::value_or` - 返回`std::optional`中的值，如果`std::optional`为空，则返回默认值。
  : `std::optional::has_value` - 返回一个`bool`值，表示`std::optional`是否包含值。
  : `std::optional::reset` - 重置`std::optional`，将其置为空。
  : `std::optional::swap` - 交换两个`std::optional`对象的值。
  : `std::optional::emplace` - 用于在`std::optional`中构造对象。
* 注意：`std::optional`是一个模板类，需要指定模板参数，用于指定所含值的类型，且`std::optional`允许使用`<`、`>`、`==`、`!=`、`<=`、`>=`和`<=>`进行比较。
#### *`std::nullopt`*
* `std::nullopt`是一个特殊的值，用于表示`std::optional`中没有值。
  > ```cpp
  >  // C++17起
  >  std::optional<int> opt = std::nullopt;
  >  ```
  详见：[optional](../src/C++17/optional_test.cpp)
* 意义：`std::nullopt`等同于`nullptr`，用于表示`std::optional`中没有值，避免了使用`nullptr`的不明确性，这也是`std::optional`的一个用处，旨在提供一个更好的方式来表示可能没有值的情况，而不是使用`nullptr`，更避免了像`C风格`中的`NULL`可以赋给任何数据类型的问题。

### *`<variant>`头文件*
#### *`std::variant`*
* `std::variant`类模板用于提供一个类型安全的`union`，即可以存储多个类型的对象，但只能同时存储其中的一个。
  > ```cpp
  >  // C++17起
  >  std::variant<int, double, std::string> var;
  >  var = 42;
  >  ```
  详见：[variant](../src/C++17/variant_test.cpp)
* 与`union`的区别：
  : union：`union`是一个共用体，可以存储多个类型的对象，但只能同时存储其中的一个，且`union`的大小为其最大成员的大小，所以`union`的成员共享同一块内存。<br>
  : variant：`std::variant`是一个类型安全的`union`，但`std::variant`的内部成员不共享内存，即各有各的内存空间，因此`type-safe`，但这也导致`std::variant`的存储效率不如`union`，特别在单片机等资源有限的环境下，`std::variant`的使用需要谨慎。
* 意义：`std::variant`是`C++17`新增的特性，用于存储多个类型的对象，但只能同时存储其中的一个，避免了`union`的类型不安全问题，常用于表示一个值可能是多种类型中的一种，如`JSON`解析、状态机和函数返回值等。
* 成员函数：
  : `std::variant::index` - 返回`std::variant`中当前值的索引。
  : `std::variant::valueless_by_exception` - 返回一个`bool`值，表示`std::variant`是否包含值。
  : `std::variant::swap` - 交换两个`std::variant`对象的值。
  : `std::variant::emplace` - 用于在`std::variant`中构造对象。
* 注意：`std::variant`是一个模板类，需要指定模板参数，用于指定所含值的类型，且`std::variant`允许使用`<`、`>`、`==`、`!=`、`<=`、`>=`和`<=>`进行比较。
#### *`非成员函数`*
* `std::get` - 用于从`std::variant`中获取对象。
  > ```cpp
  >  // C++17起
  >  std::variant<int, double, std::string> var = 42;
  >  int i = std::get<int>(var);
  >  ```
  详见：[variant](../src/C++17/variant_test.cpp)
* `std::get_if` - 用于从`std::variant`中获取对象的指针。
  > ```cpp
  >  // C++17起
  >  std::variant<int, double, std::string> var = 42;
  >  if (auto p = std::get_if<int>(&var))
  >  {
  >      std::cout << *p << std::endl;
  >  }
  >  ```
  详见：[variant](../src/C++17/variant_test.cpp)
* `std::holds_alternative` - 用于判断`std::variant`中是否包含指定类型的对象。
  > ```cpp
  > // C++17起
  > std::variant<int, double, std::string> var = 42;
  > if (std::holds_alternative<int>(var))
  > {
  >    std::cout << "int" << std::endl;
  >    std::cout << std::get<int>(var) << std::endl;
  > }
  > ```
  详见：[variant](../src/C++17/variant_test.cpp)
* `std::visit` - 用于访问`std::variant`中的对象。
  > ```cpp
  > // C++17起
  > std::variant<int, double, std::string> var = 42;
  > std::visit([](auto&& arg) {std::cout << arg << std::endl;}, var);
  > ```
  详见：[variant](../src/C++17/variant_test.cpp)
#### *`辅助类`*
* `std::bad_variant_access` - 用于辅助`std::get`进行异常处理。
  > ```cpp
  > // C++17起
  > std::variant<int, double, std::string> var = 42;
  > try
  > {
  >     std::string str = std::get<std::string>(var);
  > }
  > catch (const std::bad_variant_access& e)
  > {
  >     std::cout << e.what() << std::endl;
  > }
  > ```
  详见：[variant](../src/C++17/variant_test.cpp)
* `std::variant_size` `std::variant_size_v` - 用于获取`std::variant`中的类型数量。
  > ```cpp
  > // C++17起
  > std::variant<int, double, std::string> var = 42;
  > std::cout << std::variant_size_v<decltype(var)> << std::endl;
  > ```
  详见：[variant](../src/C++17/variant_test.cpp)
#### *`辅助类`*
* `variant_nops` - 是一个特殊的值，用于表示`std::variant`的成员变量的值为空。
  > ```cpp
  > // C++17起
  > std::variant_nops var;
  > ```
  详见：[variant](../src/C++17/variant_test.cpp)
* 意义：`variant_nops`是`C++17`新增的特性，用于表示`std::variant`的成员变量的值为空，与`std::nullopt`类似，但`variant_nops`是专门为`std::variant`设计的，用于表示`std::variant`的成员变量的值为空，而`std::nullopt`是用于表示`std::optional`的值为空。

### *`<charconv>`头文件*
* `std::from_chars`和`std::to_chars`是`C++17`新增的特性，用于将字符串和数字之间进行转换。它们保证了转换的双向性，特别是浮点数的转换，避免了精度丢失的问题。
#### *`std::from_chars`*
* `std::from_chars`是一个函数模板，用于将字符串转换为数字。
  > ```cpp
  > // C++17起
  > char str[] = "42";
  > int i;
  > std::from_chars(str, str + sizeof(str), i);
  > ```
  详见：[charconv](../src/C++17/charconv_test.cpp)
#### *`std::to_chars`*
* `std::to_chars`是一个函数模板，用于将数字转换为字符串。
  > ```cpp
  > // C++17起
  > char str[10];
  > int i = 42;
  > std::to_chars(str, str + sizeof(str), i);
  > ```
  详见：[charconv](../src/C++17/charconv_test.cpp)

### *`<execution>`头文件*
* `std::execution`是一个枚举类，用于指定执行策略。
#### *`std::is_execution_policy`*
* `std::is_execution_policy`是一个模板类，用于判断一个类型是否是执行策略。
* `std::is_execution_policy`的声明如下：
  > ```cpp
  > template <typename T>
  > struct is_execution_policy : std::false_type {};
  > ```
* 通过调用者提供的`std::execution`枚举值，可以判断是否为指定执行策略，如`std::execution::seq`、`std::execution::par`和`std::execution::par_unseq`。

### *`<filesystem>`头文件*
* 详见[filesystem](./filesystem.md)
  [^1:RVO和NRVO]: `RVO`和`NRVO`<br>
  `RVO`：返回值优化，当函数直接返回一个临时对象时，编译器会直接将接收返回值的对象在栈上分配空间，然后通过指针让函数的返回值构造在这个空间上，因为正常情况来说，需要进行1次拷贝（移动）构造、2次析构，而通过这种方式就可以避免这3次的操作开销。<br>
  `NRVO`：命名返回值优化，实现机制与RVO类似，但是不同的是，NRVO的对象是将内部创建的局部对象（具有名称），而RVO则是返回了一个匿名对象。

# C++11

## *`decltype`说明符*
* 语法:
  ```cpp
  decltype(实体)
  decltype(表达式)
  ```
* 解释: `decltype` 说明符用于获取实体或表达式的类型，但不会执行实体或表达式。
* 使用`decltype`的好处:<br>
  `decltype`可以获取实体或表达式的类型，增加代码的可读性。


## *`final`说明符*
* 语法:
  ```cpp
  class Zero final{};
  class delta : public Zero{};     // 错误,不能继承final类

  struct Alpha final{};
  struct epsilon : public Alpha{}; // 错误,不能继承final结构体

  class beta
  {
  public:
    virtual void beat::func();
  };
  
  class gamma: public beta
  {
  public:
    void beta::func() final override; 
    // OK,重写beta::func,但是无法在派生类中重写gamma::func
  };
  
  class theta: public gamma
  {
  public:
    void beta::func() override; // 错误,不能重写final函数
  };
  ```
* 解释: `final` 说明符用于禁止派生类重写基类的虚函数，或者是某个类不能被继承,意为最后的。
> 注意:<br>
> `final` 说明符只能用于虚函数，不能用于非虚函数。<br>
> `final` 说明符只能在类或结构体的定义中使用，不能在类或结构体的声明中使用。
* 使用`final`的好处:<br>
  `final`可以显示的表明某个类或者函数是不可继承或者重写的，增加代码的可读性。

## *`override`说明符*
* 语法:
  ```cpp
  struct Zero
  {
    virtual void foo(){}
    void bar(){...}
    Zero()=default;
    virtual ~Zero(){}
  }

  struct Alpha :public Zero
  {
    void foo() override{...}
    // void bar() override{...} 错误，Zero::bar不是虚函数
    ~Alpha() override{...}
    // OK, 'override'也可以用在如析构函数这样的特殊虚函数成员函数
  }
  ```
* 解释：`override` 说明符用于显式地指出一个虚函数是重写基类的虚函数，如果不是则会报错。
> 注意:<br>
> `override`并不是保留的关键字，即可在其他地方作为变量名存在.<br>
> `override`与final一样，只能用于虚函数;且如果基类使用了final，则在派生类中不能使用override。<br>
> `override`可以标识除了`析构函数`之外的所有虚函数。
* 使用`override`的好处:<br>
  `override`可以显示的表明某个函数是重写基类的虚函数，增加代码的可读性。

## *`->decltype()`尾随返回类型*
* 语法:
  ```cpp
  template<typename T, typename U>
  auto add(T t, U u) -> decltype(t+u)
  {
    return t+u;
  }
  ```
* 解释: `->decltype()`尾随返回类型用于指定函数的返回类型，可以使用函数参数的类型推导出返回类型。
> 注意:<br>
> `->decltype()`尾随返回类型只能用于函数定义，不能用于函数声明。<br>
> `->decltype()`尾随返回类型可以使用函数参数的类型推导出返回类型，但是不能使用函数体中的局部变量的类型推导出返回类型。<br>
> `->decltype()`尾随返回类型可以使用`auto`关键字，但是不能使用`decltype`关键字。<br>
> 在C++14之后，可以使用`auto`关键字代替`->decltype()`尾随返回类型，如下所示:
>  ```cpp
>  template<typename T, typename U>
>  auto add(T t, U u)
>  {
>    return t+u;
>  }
>  ```
* 使用`->decltype()`尾随返回类型的好处:<br>
  `->decltype()`显示的指定函数的返回类型，增加代码的可读性。

## *`constexpr`关键字*
* 语法:
  ```cpp
  constexpr int add(int a, int b)
  {
    return a+b;
  }
  ```
* 解释: `constexpr`关键字用于指示函数或对象是常量表达式，可以在编译时求值。
> 注意:<br>
>`constexpr`关键字与`const`关键字不同的地方在于，`constexpr`关键字如果能在在编译时求值就求值，而`const`关键字只能在运行时求值。
* 使用场景：<br> 
  C++在一些场景下必须使用常量表达式，例如：
  1. 数组的大小；
  2. 整型模板实参「如`std::array<T,N>`中的长度参数N」；
  3. 枚举的值；
  4. `switch`语句中的`case`标签；
  5. 对其规格。
* 例子：
  * `constexpr`变量：
  ```cpp
  int i1 = 42;
  constexpr int i2 = i1; // constexpr 变量 'i2' 必须由常量表达式初始化。不允许在常量表达式中读取非 const 变量 'i1'
  constexpr int i3 = 42; // i3 是常量表达式
  constexpr int i4 = i3 + 1; // i4 是常量表达式
  constexpr int i5 = getValue(); // 只有 getValue() 是 constexpr 函数时才可以，否则编译报错
  ```
  * `constexpr`函数：
  ```cpp
  constexpr int sum(int a, int b) {return a + b;}
    
  constexpr int i1 = 42;
  constexpr int i2 = sum(i1, 52); // 所有参数都是常量表达式，sum 的结果也是常量表达式，在编译期求值
    
  int AddThree(int i) {return sum(i, 3); // i 不是常量表达式，此时 sum 作为普通函数使用}
  ```
  > `constexpr`限制<br>
  > 因为需要在编译期求值，所以`constexpr`函数有一些限制：返回类型和所有形参的类型必须是字面值类型`literal type`。除了内置类型，用户自定义的类也可以是字面值类型，因为它的构造函数和成员函数也可以是`constexpr`函数。<br>
  > C++11 中`constexpr`函数还有一些额外限制「C++14 没有这些限制」：<br>
  > 返回值类型不能是`void`<br> 
  > 函数体内只能有且只有一条`return`语句「但可以用 ? : 三目运算符和递归」<br>
  > 如果是类的成员函数，则为隐式`const`成员函数
* 使用`constexpr`的好处
  1. 编译器可以保证`constexpr`对象是常量表达式（能够在编译期取得结果），而`const`对象不能保证。如果一个`const`变量能够在编译期求值，将其改为`constexpr`能够让代码更清晰易读
  2. `constexpr`函数可以把运行期计算迁移至编译期，使得程序运行更快（但会增加编译时间）

> 对于常量表达式（编译期值已知），编译器可以进行更多优化，比如放到只读内存中。但这并不是`constexpr`特有的，有的`const`变量也是常量表达式

## *委托构造函数*
* 语法:
  ```cpp
  class Base
  {
  public:
    Base(int a, int b):m_a(a),m_b(b){}
    Base(int a):Base(a,0){}
  private:
    int m_a;
    int m_b;
  };
  ```
* 解释: 委托构造函数用于在一个构造函数中调用另一个构造函数，减少代码的重复。
> 注意: <br>
> 委托构造函数只能在构造函数的成员初始化列表中调用，不能在构造函数的函数体中调用。<br>
> 委托构造函数不能递归。
* 使用委托构造函数的好处:<br> 
  委托构造函数可以减少代码的重复，提高代码的可读性。

## *继承构造函数*
* 语法:
  ```cpp
  class Base
  {
  public:
    Base(int a, int b):m_a(a),m_b(b){}
  private:
    int m_a;
    int m_b;
  };

  class Derived:public Base
  {
  public:
    using Base::Base;
  };
  ```
* 解释: 继承构造函数用于在派生类中继承基类的构造函数，即该派生类的构造函数默认调用的是基类的构造函数，减少了代码的重复。
* 使用继承构造函数的好处:<br>
  继承构造函数可以减少代码的重复，提高代码的可读性。

## *`[[  ]]`属性说明符*
* 语法:
  ```cpp
  [[属性列表]]                    // C++11
  [[using 属性命名空间:属性列表]] // C++17
  ```
* 解释: `[[  ]]`属性说明符用于指定某个实体的属性，如`[[noreturn]]`属性用于指定某个函数不会返回。
* 使用`[[  ]]`属性说明符的好处: <br>
  `[[  ]]`属性说明符提供了一种统一的语法来使用编译器厂商提供的扩展功能与优化选项。
  > C++11中的标准属性：<br>
  > 1. `[[noreturn]]`：指示函数不会返回<br>
  > 2. `[[carries_dependency]]`：指示数据依赖关系,用于并发编程(原子操作)，保证特定内存可见性和操作顺序，若不使用该属性，编译器可能会对代码进行错误优化，导致并发问题

## *`lambda`表达式*
* 语法:
  ```cpp
  auto add = [](int a, int b) {return a+b;};
  ```
* 解释: `lambda`表达式用于创建一个匿名函数对象，可以在函数内部定义函数,本质上是一个重载了`operator()`的类对象。<br>
    `[]`:捕获列表，用于捕获外部变量，可以是值传递、引用传递。 
    > 常用捕获方式和捕获对象:<br>
    > `= `   : 值传递，表示外部变量以值传递的方式传递给`lambda`表达式。<br>
    > `&`    : 引用传递，表示外部变量以引用传递的方式传递给`lambda`表达式。<br>
    > `this` : 引用传递，表示当前对象以引用传递的方式传递给`lambda`表达式。<br>
    > `*this`: 值传递，表示当前对象以值传递的方式传递给`lambda`表达式。(C++17)

    `()`:参数列表，用于传递参数。<br>
    `{}`:函数体，用于定义函数的实现。<br>
* 使用`lambda`表达式的好处:<br>
  `lambda`表达式搭配`auto`关键字可以方便快捷地创建一个匿名函数对象，提高代码的可读性。

## *`noexcept`关键字*
* 语法:
  ```cpp
  noexcept         // 表示函数不会抛出异常
  noexcept(表达式) // 如果表达式为true，则表示函数不会抛出异常，等同于noexcept
  ```
  > 可以按语境转换为`bool`类型的常量表达式

* 解释: `noexcept`说明符用于指示函数是否会抛出异常，如果函数不会抛出异常，则可以提高代码的性能，即编译器可以对代码进行优化。
* 使用`noexcept`说明符的好处:<br>
  `noexcept`说明符显示的指示函数是否会抛出异常，提高代码的可读性。
  > 注意:<br>
  > 只有异常说明不同的函数不能重载。<br>
  > 如果虚函数不会抛出，那么它每个覆盖的函数的所有声明（包括定义）都必须不抛出，除非覆盖函数被定义为弃置。<br>
  > 指向不会抛出的函数的指针（包括成员函数指针）*能赋值给或用以初始化 (C++17 前)* ***可以隐式转换到 (C++17 起)*** 指向有可能会抛出的函数的指针，但反之不可。<br>
  > 模板函数的异常说明不会影响函数模板的重载解析，但会影响特化的选择，即可以针对某些特化版本提供不同的异常说明。

## *`alignof`运算符*
* 语法:
  ```cpp
  alignof(类型)
  ```
* 解释: `alignof`运算符用于获取类型的对齐要求，即获取类型的对齐值。

## *智能指针*
* 在介绍智能指针之前，我们先介绍一些传统指针的问题:
  1. 内存泄漏：忘记释放内存。
  2. 野指针：指针指向的内存已经释放。
  3. 重复释放：同一块内存被释放多次。
  4. 不可知的释放：释放了不该释放的内存。
* 传统指针的问题是因为C++继承了C语言的指针，而C语言的指针是一个很强大的工具，但是也是一个很危险的工具，所以C++11引入了智能指针，用于解决传统指针的问题。
* 智能指针是一个类对象，用于管理指针的生命周期，即智能指针会在适当的时候自动释放内存，避免传统指针的问题，它里面封装了一个原始指针，通过重载`->`和`*`运算符，使得智能指针可以像原始指针一样使用，还维护了一个引用计数，用于记录指针的引用次数（复制，赋值，销毁），当引用计数为0时，自动释放内存。
* 智能指针的种类:
  1. `shared_ptr`：共享指针，多个指针指向同一个对象，引用计数+1。
  2. `weak_ptr`：弱指针，不增加引用计数，用于解决`shared_ptr`的循环引用问题。
  3. `unique_ptr`：独占指针，一个指针指向一个对象，引用计数为1。
* 使用智能指针需要包含头文件`#include <memory>`。

### *`unique_ptr`*
* 语法:
  ```cpp
  std::unique_ptr<int> p(new int(42));
  ```
* 解释: `unique_ptr`智能指针用于管理单个对象的内存，即一个`unique_ptr`智能指针只能指向一个对象，不能指向多个对象。
* 意义:
  1. `unique_ptr`智能指针第一次显示的表明了所有权的概念，即一个对象只能有一个所有者，当这个所有者释放内存时，其他所有者就不能再使用这个对象了，避免了传统指针的重复释放和野指针的问题，如果读者熟悉`Rust`语言，那么`unique_ptr`智能指针就是`Rust`语言的所有权转让机制。
  2. 'unique_ptr'智能指针是独享的，即不会出现内存重名的问题，所以编译器可以对`unique_ptr`智能指针进行优化，提高代码的性能。
* 注意:
  1. 不要使用一个裸指针初始化多个`unique_ptr`智能指针，因为`unique_ptr`智能指针是独享的，这样做会导致内存释放多次，导致程序崩溃。
  2. 不要使用`unique_ptr`管理不是`new`操作符分配的内存。
  3. 作为函数参数传递时，`unique_ptr`智能指针只能使用引用传递，或者使用`get()`成员函数获取裸指针传递。（不推荐,获取裸指针）
  4. `unique_ptr`本质上是类，所以它会有构造函数，析构函数，拷贝构造函数，赋值构造函数，移动构造函数，移动赋值构造函数，但是`unique_ptr`智能指针是独享的，所以它的拷贝构造函数和赋值构造函数是删除的，即不能拷贝和赋值，只能移动。
  5. 使用`exit()`函数退出程序时，全局的`unique_ptr`智能指针会自动释放内存，但是局部的`unique_ptr`智能指针不会自动释放内存，所以需要手动释放内存。
* 用法：
  1. `unique_ptr`重载了`->`和`*`运算符，可以像原始指针一样使用。
  2. `unique_ptr`智能指针可以通过`release()`成员函数释放内存，但是不会释放内存，只是释放了`unique_ptr`智能指针对内存的所有权，即`unique_ptr`智能指针不再管理这块内存，而`unique_ptr`置空。
  3. 用`unique_ptr`智能指针可以通过`reset()`成员函数释放内存，即释放`unique_ptr`智能指针对内存的所有权，同时释放内存。
  4. 用`unique_ptr`智能指针可以通过`swap()`成员函数交换内存，即交换两个`unique_ptr`智能指针对内存的所有权。
  5. 用`unique_ptr`智能指针可以通过`std::move()`转移内存，即转移了`unique_ptr`智能指针对内存的所有权。
  6. `unique_ptr`也支持多态，即可以通过基类的`unique_ptr`智能指针指向派生类的对象。
  7. `unique_ptr`提供了支持数字的实例化版本，即可以通过`unique_ptr<T[]>`智能指针管理数组。
### *`shared_ptr`*
### *make_shared函数*
* 语法:
  ```cpp
  std::shared_ptr<int> p = std::make_shared<int>(42);
  ```
* 解释: `make_shared`函数用于创建一个`std::shared_ptr`智能指针对象，可以避免显式的调用`new`操作符。
  > 注意:<br>
  > `make_shared`会调用类的构造函数，而`new`不会调用构造函数，即如果类的构造函数是私有的，`make_shared`无法创建对象。
* 使用`make_shared`函数的好处:<br>
  1. `make_shared`函数会减少一次内存分配，提高代码的性能。
  2. `make_shared`函数是异常安全的，即使在分配内存时抛出异常，也不会导致内存泄漏，因为`make_shared`函数会自动释放内存，并返回一个空的`std::shared_ptr`智能指针对象。

## *右值引用*
* 语法:
  ```cpp
  int&& a = 10;
  ```
* 解释: 右值引用用于绑定右值，即临时对象或者表达式的结果，跟引用一样，它只是右值一个别名，不会进行任何的数据操作，而且右值引用可以延长临时对象的生命周期,避免临时对象被销毁。
* 意义：
  1. 右值引用可以避免不必要的内存拷贝，因为C++默认是值传递，即变量之间默认进行的是拷贝操作，而右值引用可以避免这种拷贝操作，即将右值的地址直接赋给右值引用，避免了拷贝操作（类似于类默认进行的浅拷贝,不同的是只有一个指针指向地址，避免了内存重名现象）。
  2. 右值引用可以延长临时对象的生命周期，常见于函数返回值，比如返回一个临时对象，如果不使用右值引用，那么这个临时对象会在函数返回后被销毁，而使用右值引用可以延长这个临时对象的生命周期，使得这个临时对象在函数返回后依然存在，虽然左值引用也可以延长临时对象的生命周期，但是右值引用更加灵活，可以绑定任意类型的右值，而左值引用只能绑定左值，再者就是1.中的优点。
  3. 右值引用的使用可以减少内存的分配和释放，还有就是可以实现类似于`Rust`变量之间默认进行的所有权转让机制，即将一个变量的所有权转让给另一个变量，这样可以避免内存泄漏和野指针的问题，因为一个变量的所有权只能有一个，如果一个变量的所有权被转让给另一个变量，那么原来的变量就不能再使用了，而且因为引用的机制，也不会出现空指针的问题，实际`Rust`语言的安全性在`C++11`中也有所体现。
  4. 实际上，右值引用一般不会直接使用，而是通过`std::move`函数进行转移，即将左值转换为右值引用，这样可以避免不必要的内存拷贝，提高代码的性能，或者通过`std::forward`函数进行完美转发，即将左值引用转换为右值引用，这样可以保持左值引用的类型，提高代码的可读性。
* 注意: 右值引用虽然能接收右值，但是右值引用本身也是一个左值，即右值引用也有地址，所以不能直接将右值引用传递给接受右值引用的函数，需要通过`std::move`函数或者`std::forward`函数进行转移。

## *`std::move`函数*
* 语法:
  ```cpp
  int a = 10;
  int&& b = std::move(a);
  ```
* 解释: `std::move`函数用于将左值转换为右值引用，即将左值的地址直接赋给右值引用，避免不必要的内存拷贝。
* 意义:
  1. `std::move`函数本质上就是一个强制类型转换，将左值转换为右值引用。
  2. 主要在移动语义中使用，即将一个对象的资源所有权转移给另一个对象，其实就是对指针的转移进行了封装，避免了人为的错误操作。

## *引用折叠*
* 没有语法，只是一种规则，为了方便后续介绍`万能引用`和`完美转发`。
* 解释: 引用折叠是C++11中引入的一种规则，用于解决模板中引用的问题，即在模板中使用引用时，可能会出现引用的引用，即引用的引用，这样会导致编译器无法解析引用的引用，所以引入了引用折叠规则，即引用的引用会折叠为一个引用。
* 引用折叠规则:
  1. `T& &`折叠为`T&`,两个左值引用折叠为一个左值引用。
  2. `T& &&`折叠为`T&`,左值引用和右值引用折叠为一个左值引用。
  3. `T&& &`折叠为`T&`,右值引用和左值引用折叠为一个左值引用。
  4. `T&& &&`折叠为`T&&`,两个右值引用折叠为一个右值引用。
* 简而言之，对任何类型`T`，只要一旦出现左值引用，那么他就是左值引用，否则就是右值引用，即左值引用优先。

## *`万能引用`*
* 语法:
  ```cpp
  template<typename T>
  void func(T&& t)
  {
    ...
  }
  ```
* 解释: `万能引用`是C++11中引入的一种引用类型，简单的来说就是统一了代码的书写，即可以接受任意类型的参数，包括左值和右值，产生的原因详见`引用折叠`。

## *`std::forward`函数*
* 语法:
  ```cpp
  void func(int &&a);//右值引用
  void func(int &a);//左值引用
  ...
  int &&a =func();//返回右值引用
  func(std::forward<int>(a));//转发右值引用,即选择重载为右值引用的函数版本
  ```
* 解释: `std::forward`函数用于完美转发，即将左值引用转换为右值引用，保持左值引用的类型。
* 意义：
  1. 实际上，右值引用也是一个左值，这就导致如果直接将右值引用传递给函数，那么这个右值引用会被当做左值处理；比如我们编写了一个接受右值引用的函数，那么这个函数就无法接受右值引用，即右值引用无法传递给接受右值引用的函数，所以引入了`std::forward`函数，用于在函数参数传递之间，保持引用的类型，左值不会进行任何的处理，而右值引用本身是左值，但是通过`std::forward`函数可以将其转换为右值。
  2. 简而言之，读者大可将`std::forward`函数理解为一个有着特殊功能的`std::move`函数，即有着判断左值和右值的功能，如果是左值，那么就不进行任何处理，如果是右值，那么就调用`std::move`函数。

## *`auto &&`*
* 语法:
  ```cpp
  auto &&a = 10;
  ```
* 解释: `auto &&`是C++11中引入的一种引用类型，用于接受任意类型的参数，包括左值和右值，产生的原因详见`引用折叠`。
* 意义:`auto &&`常用于模板函数中，用于接受任意类型的参数，包括左值和右值，再通过`std::forward`函数进行完美转发，来编写一个通用的函数。

## *`iterators`迭代器*
* 语法:
  ```cpp
  std::vector<int> v = {1,2,3,4,5};
  for(auto it = v.begin(); it != v.end(); ++it)
  {
    std::cout<<*it<<std::endl;
  }
  ```
* 解释: `iterators`迭代器用于遍历容器中的元素，即通过`begin()`函数获取容器的起始位置，通过`end()`函数获取容器的结束位置，然后通过`++`运算符遍历容器中的元素。
* 意义: `iterators`迭代器提供了一种统一的遍历容器的方法，方便于模板函数的编写。
* 当然也可以简写为`for(auto &i:v)`，这样更加简洁，当然也要注意这个是引用，如果不需要引用，可以使用`for(auto i:v)`。

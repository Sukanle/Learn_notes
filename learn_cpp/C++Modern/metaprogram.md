#元编程
* 头文件：`<type_traits>`
* 最低实现：`C++11`
* 最优实现：`C++17`[^1]

##概念
* 元编程在不同的语言中有不同的定义，在`C++`中，元编程是指在编译期间进行编程，常用于模板元的编程，用于选择性的编译代码。
* 元编程与泛型编程同属于模板编程的范畴，实际上，这两者除了均为在编译期间进行编程外，没有太多的相似之处，甚至目的完全相反。泛型编程是为了设计出尽可能通用的代码，而元编程则是限制模板的使用范围，使得模板只能在特定的条件下被实例化，或者是为了在编译期间进行一些计算。
* 虽然元编程的好处是显而易见的，但是元编程的代码往往难以理解，维护困难，因此在实际编程中，应该尽量避免使用元编程，如果必须使用元编程，应该尽量保持代码的简洁和易读，而且应该尽量避免使用一些过于复杂的元编程技巧，更多使用`C++`标准库中的元编程工具，因为可以确保这些工具的正确性和可移植性，而且这些工具的使用方法也相对简单。

##类型萃取
* 类型萃取是元编程的一个重要应用，通过类型萃取，我们可以在编译期间获取类型的信息，从而进行一些操作。
* 例如，我们可以通过`std::is_pointer<T>::value`来判断类型`T`是否为指针类型，通过`std::is_integral<T>::value`来判断类型`T`是否为整数类型。
* 当然，我们也可以通过`std::enable_if`来限制模板的实例化条件，例如，我们可以通过`std::enable_if<std::is_pointer<T>::value, void>::type`来限制模板只能接受指针类型。
* 还可以在`C++20`之前通过元编程来实现`concept`的契约，就像上面的`std::enable_if`一样，限制模板的实例化条件；`std::conditional`来实现条件编译，根据条件来选择不同的类型，甚至于给函数的返回值赋予不同的类型。

* 判断类型工具,常以`is_`开头，后面跟类型名，如`is_pointer`，`is_integral`等；如果尾缀为`_v`，则表示该类型的`value`成员。
    * 基础类型，`C++`内置类型，即数据类型（包含数组，指针，枚举，共同体，类等），函数，（左右）引用。
        > 在`C++`中，结构体被当作一种没有访问限制的类，因此结构体也属于类。
    * 复合类型，用于描述基础类型的组合，如`const`，`volatile`，`pointer`，`reference`等，将基础类型分类，方便进行类型判断。
    * 类型属性，用于描述类型的属性，如`const`, `volatile`, `pointer`, `reference`等，即类型的修饰符。

##编译期处理
  * 限制模板实例化条件，`enable_if`，`enable_if_t`。
  * 条件编译，`conditional`，`conditional_t`。
---

[^1]: 由于`C++17`引入了`if constexpr`，使得元编程更加简单，因此`C++17`是最优实现的版本，且教程编写时`C++17`已经是`C++`的主流版本，但仍未全面普及，在本教程中，我们将以`C++17`为最优实现版本。
